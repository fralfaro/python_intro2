# üõ†Ô∏è Funciones

<center><img src="../images/funciones.svg" width = "550"></center><br>


## Introducci√≥n

Las funciones en Python son bloques de c√≥digo que pueden ser llamados en cualquier momento del programa. Estos bloques de c√≥digo reciben uno o varios argumentos y pueden devolver un valor. Las funciones son muy √∫tiles porque te permiten escribir c√≥digo una vez y reutilizarlo en distintas partes del programa, lo que puede ahorrar mucho tiempo y esfuerzo.

Formalmente, una funci√≥n tiene tres componentes importantes:

* los **par√°metros**, que son los valores que recibe la funci√≥n como entrada;
* el **c√≥digo de la funci√≥n**, que son las operaciones que hace la funci√≥n; y
* el **resultado** (o valor de retorno), que es el valor final que entrega la funci√≥n.

En esencia, una funci√≥n es un mini programa. Sus tres componentes son an√°logos a la entrada, el proceso y la salida de un programa.

**Definici√≥n de funciones**

Las funciones en Python lucen de la siguiente forma:

```python
def nombre(parametro_1,...,parametro_n):
    """
    Descripcion de la funcion (opcional)
    """
    # c√≥digo de la funci√≥n
    resultado = operacion(parametro_1,...,parametro_n)
    return resultado # output de la funcion
```

Se utiliza la palabra clave `def` seguida del nombre de la funci√≥n, los par√°metros que recibe entre par√©ntesis y dos puntos `:`. El cuerpo de la funci√≥n va indentado y puede contener cualquier c√≥digo que se quiera ejecutar. Para devolver un valor se utiliza la palabra clave `return`.

```{pyodide-python}
def suma(a, b):
    return a + b

resultado = suma(3, 5)
print(resultado)
```

En este ejemplo se define una funci√≥n llamada `suma` que recibe dos par√°metros `a` y `b` y devuelve la suma de ambos. Se llama a la funci√≥n con los valores `3` y `5` y se almacena el resultado en una variable llamada `resultado`. Finalmente, se imprime el valor de `resultado`.

Por otro lado, dado que no se especifica el tipo de datos, podemos sumar dos `strings`

```{pyodide-python}
resultado = suma("Hola ","Mundo")
print(resultado)
```

Por lo que se debe tener cuidado tanto con el nombre de la funci√≥n (se espera que pueda resumir la funcion en una o dos palabras) y el tipo de argumentos que queremos que reciba.

Las funciones tambi√©n pueden tener argumentos opcionales que tienen un valor por defecto. Para definir un argumento opcional se utiliza el operador `=` para asignarle un valor por defecto. El valor por defecto se utiliza si el argumento no es especificado al llamar a la funci√≥n.

```{pyodide-python}
def saludo(nombre, saludo="Hola"):
    print(saludo, nombre)

saludo("Pedro")
saludo("Maria", "Buenos d√≠as")
```

En este ejemplo se define una funci√≥n llamada `saludo` que recibe dos argumentos, `nombre` y `saludo`. El argumento saludo tiene un valor por defecto de `"Hola"`. La funci√≥n imprime el mensaje de saludo utilizando los valores de `saludo` y `nombre`. Se llama a la funci√≥n con diferentes valores de argumentos.

A continuaci√≥n, se crear√° la funci√≥n `factorial`, la cual entregar√° el [factorial](https://es.wikipedia.org/wiki/Factorial#:~:text=7%20Enlaces%20externos-,Definici%C3%B3n%20por%20producto%20e%20inducci%C3%B3n,menores%20o%20iguales%20que%20n.) de un n√∫mero entero no negativo.

```{pyodide-python}
def factorial(n):
    """
    factorial de un numero entero no negativo
    """
    f = 1
    for i in range(1, n + 1):
        f *= i
    return f
```

En este ejemplo, el resultado que entrega una llamada a la funci√≥n es el valor que tiene la variable `f` al llegar a la √∫ltima l√≠nea de la funci√≥n.

Una vez creada, la funci√≥n puede ser usada como cualquier otra, todas las veces que sea necesario:

```{pyodide-python}
print(factorial(0))
```

```{pyodide-python}
print(factorial(2) + factorial(5))
```

Las variables que son creadas dentro de la funci√≥n (incluyendo los par√°metros y el resultado) se llaman **variables locales**, y s√≥lo son visibles dentro de la funci√≥n, no desde el resto del programa.

Por otra parte, las variables creadas fuera de alguna funci√≥n se llaman **variables globales**, y son visibles desde cualquier parte del programa. Sin embargo, su valor no puede ser modificado, ya que una asignaci√≥n crear√≠a una variable local del mismo nombre.




```{pyodide-python}
# ejemplo variable global

valor = 10 # variable global

def funcion_01(x):
    return valor*x
```

```{pyodide-python}
print(funcion_01(5))
```

```{pyodide-python}
# ejemplo variable local

def funcion_02(x,valor):
    
    resultado = valor*x
    
    return resultado
```

```{pyodide-python}
print(funcion_02(5,2))
```

> **Nota**: Dependiendo del uso que le d√© a su c√≥digo es que ocupar√° variables globales o no, sin embargo, es preferible definir su funci√≥n **solo con variables locales**, puesto que esto deja expl√≠cita la dependencia de dicha variable dentro de su funci√≥n objetivo.

Por otro lado, existen funciones que **no necesariamente** reciben argumentos.

```{pyodide-python}
def imprimir_pantalla():
    return "Mensaje random"
```

```{pyodide-python}
imprimir_pantalla()
```

Tambi√©n, existen funciones que **no retornan valores**:

```{pyodide-python}
def imprimir_nombre(nombre):
    print(nombre)
```

```{pyodide-python}
imprimir_nombre("nombre_01")
```

## Formas de escribir una funci√≥n

### Recursion



Una funci√≥n que se llama a s√≠ misma se conoce como funci√≥n recursiva y este proceso se llama **recursividad**. Cada funci√≥n recursiva debe tener una condici√≥n base que detenga la recursividad o, de lo contrario, la funci√≥n se llama a s√≠ misma infinitamente.

```{pyodide-python}
# funcion factorial (recursivo)

def factorial(n):
    """
    Funcion factorial de manera recursiva
    """
    if n == 1:
        return 1
    else:
        return (n * factorial(n-1))    
```

Analicemos recursivamente el factorial del n√∫mero $3$.



<img src="https://raw.githubusercontent.com/fralfaro/python_intro/main/docs/images/fact.png"  align="center" width="400" /> <br>


```{pyodide-python}
num = 3
print(f"El factorial de {num} es {factorial(num)}") 
```

### Lambda

En Python, puedes definir funciones sin nombre utilizando funciones lambda o, como tambi√©n se les conoce, funciones an√≥nimas. Estas funciones son √∫tiles para realizar operaciones simples en una sola l√≠nea de c√≥digo. Para crear una funci√≥n lambda, se utiliza la palabra clave `lambda`. A continuaci√≥n, te presento una comparaci√≥n entre una funci√≥n definida de manera convencional y una funci√≥n lambda:

**Funci√≥n Definida de Manera Convencional:**

```{pyodide-python}
def cuadrado_normal(x):
    """
    Funci√≥n que eleva al cuadrado un n√∫mero.
    """
    return x ** 2

# Llamamos a la funci√≥n convencional
resultado_normal = cuadrado_normal(5)
print(resultado_normal)
```

**Funci√≥n Lambda:**

```{pyodide-python}
# Definimos una funci√≥n lambda para elevar al cuadrado un n√∫mero
cuadrado = lambda x: x ** 2

# Llamamos a la funci√≥n lambda
resultado_lambda = cuadrado(5)
print(resultado_lambda)
```

**Explicaci√≥n:**

- En el primer ejemplo, se define una funci√≥n convencional llamada `cuadrado_normal` que toma un argumento `x` y devuelve el cuadrado de `x` utilizando la declaraci√≥n `return`.

- En el segundo ejemplo, se crea una funci√≥n lambda que realiza la misma operaci√≥n. La funci√≥n lambda se define como `lambda x: x ** 2`, donde `x` es el argumento de entrada y `x ** 2` es la expresi√≥n que se eval√∫a y devuelve.

- Luego, llamamos tanto a la funci√≥n convencional como a la funci√≥n lambda con un valor de `5` como argumento, y guardamos los resultados en las variables `resultado_normal` y `resultado_lambda`, respectivamente.

- Finalmente, imprimimos los resultados, que ser√°n `25` tanto para la funci√≥n convencional como para la funci√≥n lambda, ya que ambas calculan el cuadrado de `5`.

### Utilizando `*args` y `**kwargs`

En Python, puedes utilizar `*args` y `**kwargs` para manejar un n√∫mero variable de argumentos en una funci√≥n. Estos nombres, `args` y `kwargs`, son convenciones comunes, pero en realidad puedes nombrarlos como desees. Ahora, profundicemos en estos conceptos:

* `*args`: Es una convenci√≥n para indicar que se acepta un n√∫mero variable de argumentos no nombrados (posicionales). Los argumentos se almacenan en una tupla.

* `**kwargs`: Es una convenci√≥n para indicar que se acepta un n√∫mero variable de argumentos con nombre. Los argumentos se almacenan en un diccionario, donde las claves se convierten en los nombres de los par√°metros y los valores son los argumentos asociados.

**Usando `*args`:**

```{pyodide-python}
def sumar_numeros(*numeros):
    suma = 0
    for numero in numeros:
        suma += numero
    return suma

resultado = sumar_numeros(1, 2, 3, 4)
print(resultado)
```

En el primer ejemplo, se define la funci√≥n `sumar_numeros`, que toma un n√∫mero variable de argumentos no nombrados. La funci√≥n suma todos los argumentos recibidos y devuelve el resultado. En este caso, llamamos a la funci√≥n con los n√∫meros `1, 2, 3, 4`, y la suma se almacena en `resultado`.

**Usando `**kwargs`:**

```{pyodide-python}
def imprimir_datos(**datos):
    for llave, valor in datos.items():
        print(llave, ":", valor)

imprimir_datos(nombre="Juan", edad=25, ciudad="Lima")
```

En el segundo ejemplo, se define la funci√≥n `imprimir_datos`, que toma un n√∫mero variable de argumentos con nombre. La funci√≥n itera a trav√©s del diccionario `datos` y muestra las claves y sus valores asociados. Llamamos a la funci√≥n con argumentos con nombre, como "nombre", "edad" y "ciudad", y se imprime la informaci√≥n correspondiente.

> **Nota**: Es importante recordar que aunque `*args` y `**kwargs` son √∫tiles, se recomienda ser expl√≠cito en la definici√≥n de tus funciones siempre que sea posible para hacer el c√≥digo m√°s legible y mantenible.

## Ejercicios


**Ejercicio 01**

Escriba una funci√≥n que se llame `saludar` que reciba como input un string **s** y devuelva como output "Hola + valor de s".
* **Ejemplo**: *saludar("mundo")* = "Hola mundo"

```{pyodide-python}
# respuesta
```

**Ejercicio 02**

Escriba una funci√≥n que se llame `es_par` que reciba como input un n√∫mero entero **n** y devuelva como output *True* si el n√∫mero es par, y *False* en otro caso.

* **Ejemplo**: 
    * *es_par(4)* = True
    * *es_par(3)* = False

```{pyodide-python}
# respuesta
```

**Ejercicio 03**

Escriba la funci√≥n `invertir_digitos(n)` que reciba un n√∫mero entero n y entregue como resultado el n√∫mero `n` con los d√≠gitos en el orden inverso:

```terminal
 >>> invertir_digitos(142)
241
```
 
A continuaci√≥n, escriba un programa que indique si el n√∫mero ingresado es pal√≠ndromo o no, usando la funci√≥n `invertir_digitos`:

```terminal
Ingrese n: 81418
Es pal√≠ndromo
```



```{pyodide-python}
# respuesta
```

**Ejercicio 04**



Muchos de estos programas s√≥lo ten√≠an peque√±as diferencias entre ellos, por lo que hab√≠a que repetir mucho c√≥digo al escribirlos. En este ejercicio, usted deber√° implementar algunos de esos programas como funciones, reutilizando componentes para evitar escribir c√≥digo repetido.


**Ejercicio 041**

Escriba la funci√≥n `es_divisible(n, d)` que indique si `n` es divisible por `d`:

```
>>> es_divisible(15, 5)
True
>>> es_divisible(15, 6)
False
```

**Ejercicio 042**

Usando la funci√≥n es_divisible, escriba una funci√≥n `es_primo(n)` que determine si un n√∫mero es primo o no:

```
>>> es_primo(17)
True
>>> es_primo(221)
False
```

**Ejercicio 043**

Usando la funci√≥n `es_primo`, escriba la funci√≥n `i_esimo_primo(i)` que entregue el i-√©simo n√∫mero primo.

```
>>> i_esimo_primo(1)
2
>>> i_esimo_primo(20)
71
```

**Ejercicio 044**

Usando las funciones anteriores, escriba la funci√≥n `primeros_primos(m)` que entregue una lista de los primeros m n√∫meros primos:

```
>>> primeros_primos(10)
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
```

**Ejercicio 045**

Usando las funciones anteriores, escriba la funci√≥n `primos_hasta(m)` que entregue una lista de los primos menores o iguales que `m`:

```
>>> primos_hasta(19)
[2, 3, 5, 7, 11, 13, 17, 19]
```

**Ejercicio 046**

Un [primo de Mersenne](https://es.wikipedia.org/wiki/N%C3%BAmero_primo_de_Mersenne) es un n√∫mero primo de la forma $2p‚àí1$. 
Una propiedad conocida de los primos de Mersenne es que $p$ debe ser tambi√©n un n√∫mero primo.

Escriba la funci√≥n `mersenne` que pregunte al usuario un n√∫mero $n$, y muestre como salida los primeros `n` primos de Mersenne:

```
>>> mersenne(5)
3
7
31
127
8191
```

```{pyodide-python}
# respuesta
```

**Ejercicio 05**

La suma natural de los primeros **n** n√∫meros naturales esta dado por:
$$\displaystyle S = \sum_{k=1}^{n} k = 1 +2 +3 +...+n = \dfrac{n(n+1)}{2} $$

Escriba una funci√≥n que se llame `suma_numeros_naturales` que reciba como input un n√∫mero entero **n** y devuelva como output la suma de los primeros **n** n√∫meros naturales. 

Para esto:

* a) Programe la funci√≥n ocupando la f√≥rmula manual: $S = 1+2+3+..+n$
* b) Programe la funci√≥n ocupando la f√≥rmula cerrada: $S =\dfrac{n(n+1)}{2} $

**Ejemplo**: 
   * *suma_numeros_naturales(1)* = 1
   * *suma_numeros_naturales(10)* = 55
   * *suma_numeros_naturales(100)* = 5050



```{pyodide-python}
# respuesta

```

**Ejercicio 06**

En los siglos XVII y XVIII, James Gregory y Gottfried Leibniz descubrieron una serie infinita que sirve para calcular $\pi$:

$$\displaystyle \pi = 4 \sum_{k=1}^{\infty}\dfrac{(-1)^{k+1}}{2k-1} = 4(1-\dfrac{1}{3}+\dfrac{1}{5}-\dfrac{1}{7} + ...) $$

Desarolle un programa para estimar el valor de $\pi$ ocupando el m√©todo de Leibniz, donde la entrada del programa debe ser un n√∫mero entero $n$ que indique cu√°ntos t√©rminos de la suma se utilizar√°.


* **Ejemplo**: 
    * *calcular_pi(3)* = 3.466666666666667
    * *calcular_pi(1000)* = 3.140592653839794

```{pyodide-python}
# respuesta
```

**Ejercicio 07**

Euler realiz√≥ varios aportes en relaci√≥n a $e$, pero no fue hasta 1748 cuando public√≥ su **Introductio in analysin infinitorum** que dio un tratamiento definitivo a las ideas sobre $e$. All√≠ mostr√≥ que:


En los siglos XVII y XVIII, James Gregory y Gottfried Leibniz descubrieron una serie infinita que sirve para calcular œÄ:

$$\displaystyle e = \sum_{k=0}^{\infty}\dfrac{1}{k!} = 1+\dfrac{1}{2!}+\dfrac{1}{3!}+\dfrac{1}{4!} + ... $$

Desarolle un programa para estimar el valor de $e$ ocupando el m√©todo de Euler, donde la entrada del programa debe ser un n√∫mero entero $n$ que indique cu√°ntos t√©rminos de la suma se utilizar√°. 

Para esto:

* a) Defina la funci√≥n `factorial`, donde la entrada sea un n√∫mero natural  $n$ y la salida sea el factorial de dicho n√∫mero.
    * **Ejemplo**: *factorial(3)* =3, *factorial(5)* = 120
    
    
* b) Ocupe la funci√≥n `factorial` dentro de la funci√≥n `calcular_e`.     
    * **Ejemplo**: *calcular_e(3)* = 2.6666666666666665, *calcular_e(1000)* = 2.7182818284590455

```{pyodide-python}
# respuesta

```

**Ejercicio 08**

Sea $\sigma(n)$ definido como la suma de los divisores propios de $n$ (n√∫meros menores que n que se dividen en $n$).

Los [n√∫meros amigos](https://en.wikipedia.org/wiki/Amicable_numbers) son  enteros positivos $n_1$ y $n_2$ tales que la suma de los divisores propios de uno es igual al otro n√∫mero y viceversa, es decir, $\sigma(n_1)=\sigma(n_2)$ y $\sigma(n_2)=\sigma(n_1)$.


Por ejemplo, los n√∫meros 220 y 284 son n√∫meros amigos.
* los divisores propios de 220 son 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 y 110; por lo tanto $\sigma(220) = 284$. 
* los divisores propios de 284 son 1, 2, 4, 71 y 142; entonces $\sigma(284) = 220$.


Implemente una funci√≥n llamada `amigos` cuyo input sean dos n√∫meros naturales $n_1$ y $n_2$, cuyo output sea verifique si los n√∫meros son amigos o no. 

Para esto:

* a) Defina la funci√≥n `divisores_propios`, donde la entrada sea un n√∫mero natural $n$ y la salida sea una lista con los divisores propios de dicho n√∫mero.
    * **Ejemplo**: *divisores_propios(220)* = [1, 2, 4, 5, 10, 11, 20, 22, 44, 55 y 110], *divisores_propios(284)* = [1, 2, 4, 71 y 142]
    
    
* b) Ocupe la funci√≥n `divisores_propios` dentro de la funci√≥n `amigos`.

    * **Ejemplo**: *amigos(220,284)* = True, *amigos(6,5)* = False

```{pyodide-python}
# respuesta
```

**Ejercicio 09**

La [conjetura de Collatz](https://en.wikipedia.org/wiki/Collatz_conjecture), conocida tambi√©n como conjetura $3n+1$ o conjetura de Ulam (entre otros nombres), fue enunciada por el matem√°tico Lothar Collatz en 1937, y a la fecha no se ha resuelto.

Sea la siguiente operaci√≥n, aplicable a cualquier n√∫mero entero positivo:
* Si el n√∫mero es par, se divide entre 2.
* Si el n√∫mero es impar, se multiplica por 3 y se suma 1.

La conjetura dice que siempre alcanzaremos el 1 (y por tanto el ciclo 4, 2, 1) para cualquier n√∫mero con el que comencemos. 

Implemente una funci√≥n llamada `collatz` cuyo input sea un n√∫mero natural positivo $N$ y como output devulva la secuencia de n√∫meros hasta llegar a 1.

* **Ejemplo**: *collatz(9)* = [9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]

```{pyodide-python}
# respuesta
```

**Ejercicio 10**

La [conjetura de Goldbach](https://en.wikipedia.org/wiki/Goldbach%27s_conjecture) es uno de los problemas abiertos m√°s antiguos en matem√°ticas. Concretamente, G.H. Hardy, en 1921, en su famoso discurso pronunciado en la Sociedad Matem√°tica de Copenhague, coment√≥ que probablemente la conjetura de Goldbach no es solo uno de los problemas no resueltos m√°s dif√≠ciles de la teor√≠a de n√∫meros, sino de todas las matem√°ticas. Su enunciado es el siguiente:

> Todo n√∫mero par mayor que 2 puede escribirse como suma de dos n√∫meros primos - Christian Goldbach (1742)

Implemente una funci√≥n llamada `goldbach` cuyo input sea un n√∫mero natural positivo $n$ y como output devuelva la suma de dos primos ($n_1$ y $n_2$) tal que: $n_1+n_2=n$. 

Para esto:

* a) Defina la funci√≥n `es_primo`, donde la entrada sea un n√∫mero natural $n$ y la salida sea **True** si el n√∫mero es primo y **False** en otro caso.
    * **Ejemplo**: *es_primo(3)* = True, *es_primo(4)* = False
    
    
* b)  Defina la funci√≥n `lista_de_primos`, donde la entrada sea un n√∫mero natural par $n$ mayor que dos y la salida sea una lista con todos los n√∫mero primos entre 2 y $n$.
    * **Ejemplo**: *lista_de_primos(4)* = [2,3], *lista_de_primos(6)* = [2,3,5], *lista_de_primos(8)* = [2,3,5,7]


* c) Ocupe la funci√≥n `lista_de_primos` dentro de la funci√≥n `goldbash`.
 * **Ejemplo**: goldbash(4) = (2,2), goldbash(6) = (3,3) , goldbash(8) = (3,5)

**Ejercicio 11**

El [producto interno](https://es.wikipedia.org/wiki/Producto_escalar) de dos listas de n√∫meros es la suma de los productos de los t√©rminos correspondientes de ambas.

Por ejemplo, si:
```
a = [5, 1, 6]
b = [1, -2, 8]
```

entonces el producto interno entre $a$ y $b$ es:

```
(5 * 1) + (1 * -2) + (6 * 8)
```

1. Escriba la funci√≥n `producto_interno(a, b)` que entregue el producto interno de `a` y `b`:

    ```
    >>> a = [7, 1, 4, 9, 8]
    >>> b = range(5)
    >>> producto_interno(a, b)
    68
    ```

2. Dos listas de n√∫meros son [ortogonales](https://es.wikipedia.org/wiki/Producto_escalar#Vectores_ortogonales) si su producto interno es cero. Escriba la funci√≥n `son_ortogonales(a, b)` que indique si `a` y `b` son ortogonales:

    ```
    >>> son_ortogonales([2, 1], [-3, 6])
    True
    ```  


```{pyodide-python}
# respuesta
```

**Ejercicio 12**


Una fecha puede ser representada como una tupla `(anno, mes, dia)`.

1. Escriba la funci√≥n `dia_siguiente(f)` que reciba como par√°metro una fecha `f` y entegue cu√°l es la fecha siguiente:

    ```
    >>> dia_siguiente((2011, 4, 11))
    (2011, 4, 12)
    >>> dia_siguiente((2011, 4, 30))
    (2011, 5, 1)
    >>> dia_siguiente((2011, 12, 31))
    (2012, 1, 1)
    ```
    
    Como recomendaci√≥n, dentro de su funci√≥n use una lista con la cantidad de d√≠as que tiene cada mes:
    
    ```
    dias_mes = [31, 28, 31, 30,
            31, 30, 31, 31,
            30, 31, 30, 31]
    ```
    

2. Escriba la funci√≥n `dias_entre(f1, f2)` que retorne la cantidad de d√≠as que han transcurrido entre las fechas `f1` y `f2`:

    ```
    >>> hoy = (2011, 4, 11)
    >>> navidad = (2011, 12, 25)
    >>> dias_entre(hoy, navidad)
    258
    >>> dias_entre(hoy, hoy)
    0
    ```

```{pyodide-python}
# respuesta
```

**Ejercicio 13**


El [conjunto potencia](https://es.wikipedia.org/wiki/Conjunto_potencia) de un conjunto $S$ es el conjunto de todos los subconjuntos de $S$.

Por ejemplo, el conjunto potencia de $\{1,2,3\}$
 es:

$$\{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{1,3\},\{2,3\},\{1,2,3\}\}$$

En Python, un conjunto no puede contener a otros conjuntos, ya que no puede tener elementos mutables, y los conjuntos lo son:


```{pyodide-python}
>>> a = set()
>>> a.add({1, 2})        # :(
Traceback (most recent call last):
  File "<console>", line 1, in <module>
TypeError: unhashable type: 'set'
```

Lo que s√≠ podemos crear es una lista de conjuntos:

```{pyodide-python}
>>> l = list()
>>> l.append({1, 2})     # :)
>>> l
[set([1, 2])]
```

Escriba la `funci√≥n conjunto_potencia(s)` que reciba como par√°metro un conjunto cualquiera `s` y retorne su ¬´lista potencia¬ª (la lista de todos sus subconjuntos):

```{pyodide-python}
>>> conjunto_potencia({6, 1, 4})
[set(), set([6]), set([1]), set([4]), set([6, 1]), set([6, 4]), set([1, 4]), set([6, 1, 4])]
```

```{pyodide-python}
# respuesta
```

**Ejercicio 14**

Para este ejercicio considere lo siguiente:

Para obtener la lista de palabras de la oraci√≥n, puede usar el m√©todo `split` de los strings:

```{pyodide-python}
>>> s = 'el gato y el pato'
>>> s.split()
['el', 'gato', 'y', 'el', 'pato']
```

Para obtener un string en min√∫sculas, puede usar el m√©todo lower:

```{pyodide-python}
>>> s = 'Venezuela'
>>> s.lower()
'venezuela'
```

1. Escriba la funci√≥n `contar_letras(oracion)` que retorne un diccionario asociando a cada letra la cantidad de veces que aparece en la oracion:

    ```
    >>> contar_letras('El elefante avanza hacia Asia')
    {'a': 8, 'c': 1, 'e': 4, 'f': 1, 'h': 1, 'i': 2, 'l': 2, 'n': 2, 's': 1, 't': 1, 'v': 1, 'z': 1}
    ```

    Cada valor del diccionario debe considerar tanto las apariciones en may√∫scula como en min√∫scula de la letra correspondiente. Los espacios deben ser ignorados.

2. Escriba la funci√≥n `contar_vocales(oracion)` que retorne un diccionario asociando a cada vocal la cantidad de veces que aparece en la oracion. Si una vocal no aparece en la oraci√≥n, de todos modos debe estar en el diccionario asociada al valor 0:

    ```
    >>> contar_vocales('El elefante avanza hacia Asia')
    {'a': 8, 'e': 4, 'i': 2, 'o': 0, 'u': 0}
    ```


3. Escriba la funci√≥n `contar_iniciales(oracion)` que retorne un diccionario asociando a cada letra la cantidad de veces que aparece al principio de una palabra:

    ```
    >>> contar_iniciales('El elefante avanza hacia Asia')
    {'e': 2, 'h': 1, 'a': 2}
    >>> contar_iniciales('Varias vacas vuelan sobre Venezuela')
    {'s': 1', 'v': 4}
    ```


4. Escriba la funci√≥n `obtener_largo_palabras(oracion)` que retorne un diccionario asociando a cada palabra su cantidad de letras:

    ```
    >>> obtener_largo_palabras('el gato y el pato son amigos')
    {'el': 2, 'son': 3, 'gato': 4, 'y': 1, 'amigos': 6, 'pato': 4}
    ```


5. Escriba la funci√≥n `contar_palabras(oracion)` que retorne un diccionario asociando a cada palabra la cantidad de veces que aparece en la oraci√≥n:

    ```
    >>> contar_palabras('El sobre esta sobre el pupitre')
    {'sobre': 2, 'pupitre': 1, 'el': 2, 'esta': 1}
    ```

6. Escriba la funci√≥n `palabras_repetidas(oracion)` que retorne una lista con las palabras que est√°n repetidas:

    ```
    >>> palabras_repetidas('El partido termino cero a cero')
    ['cero']
    >>> palabras_repetidas('El sobre esta sobre el mueble')
    ['el', 'sobre']
    >>> palabras_repetidas('Ay, ahi no hay pan')
    []
    ```

```{pyodide-python}
# respuesta
```